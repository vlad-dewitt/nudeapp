// Generated by CoffeeScript 2.4.1
var MediaViewer, Shape, _class,
  boundMethodCheck = function(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new Error('Bound instance method accessed before binding'); } };

import Carousel from '../../tools/carousel';

MediaViewer = _class = class extends Component {
  constructor(props) {
    super(props);
    this.componentDidMount = this.componentDidMount.bind(this);
    this.componentDidUpdate = this.componentDidUpdate.bind(this);
    this.componentWillUnmount = this.componentWillUnmount.bind(this);
    this.init = this.init.bind(this);
    this.onOrientationChange = this.onOrientationChange.bind(this);
    this.changeObject = this.changeObject.bind(this);
    this.videoPlaybackStatusChange = this.videoPlaybackStatusChange.bind(this);
    this.focus = this.focus.bind(this);
    this.pinch = this.pinch.bind(this);
    this.pinchStateChange = this.pinchStateChange.bind(this);
    this.share = this.share.bind(this);
    this.export = this.export.bind(this);
    this.delete = this.delete.bind(this);
    this.cancel = this.cancel.bind(this);
    this.render = this.render.bind(this);
    this.state = {
      objects: [],
      current_object: {},
      orientation: 'PORTRAIT'
    };
    this.zoom = {
      scale: new Animated.Value(1),
      position: {
        x: 0,
        y: 0
      },
      translateX: new Animated.Value(0),
      translateY: new Animated.Value(0)
    };
    this.videos = {};
  }

  componentDidMount() {
    boundMethodCheck(this, _class);
    ScreenOrientation.unlockAsync();
    ScreenOrientation.addOrientationChangeListener(this.onOrientationChange);
    return this.init();
  }

  componentDidUpdate() {
    boundMethodCheck(this, _class);
    return this.init();
  }

  componentWillUnmount() {
    boundMethodCheck(this, _class);
    Ambry.call('clearMediaViewer');
    ScreenOrientation.removeOrientationChangeListeners();
    return ScreenOrientation.lockAsync(ScreenOrientation.Orientation.PORTRAIT);
  }

  init() {
    var objects;
    boundMethodCheck(this, _class);
    if (!_.isEqual(this.props.app.media_viewer.objects, this.state.objects)) {
      objects = [];
      this.props.app.media_viewer.objects.map((object, num) => {
        object.index = num;
        return objects.push(object);
      });
      return this.setState({
        objects: objects,
        current_object: objects[this.props.app.media_viewer.first]
      });
    }
  }

  onOrientationChange(e) {
    var orientation;
    boundMethodCheck(this, _class);
    orientation = e.orientationInfo.orientation.includes('PORTRAIT') ? 'PORTRAIT' : 'LANDSCAPE';
    this.setState({
      orientation: orientation
    });
    return this.changeObject(this.state.current_object.index);
  }

  changeObject(number) {
    boundMethodCheck(this, _class);
    if (this.videos[this.state.current_object.id]) {
      this.videos[this.state.current_object.id].stopAsync();
    }
    return this.setState({
      current_object: this.state.objects[number]
    });
  }

  videoPlaybackStatusChange(status) {
    var playing;
    boundMethodCheck(this, _class);
    if (status.isPlaying) {
      playing = true;
    } else {
      playing = false;
    }
    if (this.state.current_object.isPlaying !== playing) {
      return this.setState({
        current_object: {
          ...this.state.current_object,
          isPlaying: playing
        }
      }, () => {
        if (playing) {
          return this.focus();
        }
      });
    }
  }

  focus(value) {
    boundMethodCheck(this, _class);
    if (value !== true && value !== false) {
      value = this.props.app.media_viewer.focus === true ? false : true;
    }
    if (this.props.app.media_viewer.focus !== value) {
      if (this.state.current_object.isPlaying) {
        return Ambry.call('setMediaViewerFocus', true);
      } else {
        return Ambry.call('setMediaViewerFocus', value);
      }
    }
  }

  pinch({
      nativeEvent: event
    }) {
    boundMethodCheck(this, _class);
    if (event.state === GestureState.ACTIVE) {
      this.focus(true);
      if (event.scale > 0.8 && event.scale < 3) {
        Animated.spring(this.zoom.scale, {
          toValue: event.scale,
          speed: 400,
          useNativeDriver: true
        }).start();
      }
      Animated.spring(this.zoom.translateX, {
        toValue: event.focalX - this.zoom.position.x,
        speed: 400,
        useNativeDriver: true
      }).start();
      return Animated.spring(this.zoom.translateY, {
        toValue: event.focalY - this.zoom.position.y,
        speed: 400,
        useNativeDriver: true
      }).start();
    }
  }

  pinchStateChange({
      nativeEvent: event
    }) {
    boundMethodCheck(this, _class);
    if (event.state === GestureState.BEGAN) {
      this.zoom.position = {
        x: event.focalX,
        y: event.focalY
      };
    }
    if (event.state === GestureState.END) {
      this.zoom.position = {
        x: 0,
        y: 0
      };
      Animated.timing(this.zoom.scale, {
        toValue: 1,
        duration: 200,
        useNativeDriver: true
      }).start();
      Animated.timing(this.zoom.translateX, {
        toValue: 0,
        duration: 200,
        useNativeDriver: true
      }).start();
      return Animated.timing(this.zoom.translateY, {
        toValue: 0,
        duration: 200,
        useNativeDriver: true
      }).start();
    }
  }

  share() {
    boundMethodCheck(this, _class);
    return Sharing.shareAsync(this.state.current_object.path);
  }

  export() {
    boundMethodCheck(this, _class);
    return Alert.alert("Export this files?", '', [
      {
        text: 'No',
        style: 'cancel'
      },
      {
        text: 'Yes',
        onPress: () => {
          return API.global.exportMedia([this.state.current_object],
      () => {
            return this.cancel();
          });
        }
      }
    ]);
  }

  delete() {
    boundMethodCheck(this, _class);
    return Alert.alert('Are you sure?', 'This action can\'t be undone', [
      {
        text: 'Cancel',
        style: 'cancel'
      },
      {
        text: 'Delete',
        onPress: () => {
          API.global.removeMedia([this.state.current_object]);
          return this.cancel();
        }
      }
    ]);
  }

  cancel() {
    boundMethodCheck(this, _class);
    return this.props.navigation.goBack();
  }

  render() {
    boundMethodCheck(this, _class);
    return <View style={{
        ...Shape.Box,
        height: Dimensions.get('window').height
      }}>
      {(this.state.objects.length > 0 ? <View style={Shape.Content}>
            <Carousel pageStyle={{
        ...Shape.MediaSlider,
        height: Dimensions.get('window').height
      }} width={Dimensions.get('window').width} pageWidth={Dimensions.get('window').width} swipeThreshold={.3} sneak={0} onPageChange={this.changeObject} currentPage={this.state.current_object.index}>
              {this.state.objects.map((object, num) => {
      if (this.state.current_object.index - 1 === num || this.state.current_object.index === num || this.state.current_object.index + 1 === num) {
        return <TouchableOpacity key={num} style={Shape.MediaSliderItem} activeOpacity={1} onPress={this.focus}>
                      <View style={{
            width: '100%',
            height: '100%'
          }}>
                        {(object.type === 'image' ? <PinchGestureHandler onGestureEvent={this.pinch} onHandlerStateChange={this.pinchStateChange}>
                              <Animated.Image source={{
            uri: object.path
          }} style={{
            width: '100%',
            height: '100%',
            resizeMode: 'contain',
            transform: [
              {
                scale: this.zoom.scale
              },
              {
                translateX: 0
              },
              {
                translateY: 0
              }
            ]
          }} />
                            </PinchGestureHandler> : object.type === 'video' ? <Video ref={(ref) => {
            return this.videos[object.id] = ref;
          }} source={{
            uri: object.path
          }} rate={1.0} volume={1.0} isMuted={false} resizeMode='contain' shouldPlay={false} useNativeControls isLooping={false} style={{
            width: '100%',
            height: '100%'
          }} onPlaybackStatusUpdate={this.videoPlaybackStatusChange} /> : void 0)}
                      </View>
                    </TouchableOpacity>;
      }
    })}
            </Carousel>
            {(!this.props.app.media_viewer.focus ? <View style={{
        ...Shape.MediaMenu,
        top: Dimensions.get('window').height - 56,
        paddingHorizontal: this.state.orientation === 'PORTRAIT' ? Dimensions.get('window').width / 6 : Dimensions.get('window').width / 3
      }}>
                  <StatusBar hidden={false} />
                  <TouchableOpacity style={Shape.MediaMenuIcon} activeOpacity={.5} onPress={this.share}>
                    <Image source={Assets.img.icons.share_linear_icon} style={{
        width: 20,
        height: 20,
        resizeMode: 'contain',
        marginBottom: 5
      }} />
                    <Text style={[Typography.Light, Typography.Little]}>Share</Text>
                  </TouchableOpacity>
                  <TouchableOpacity style={Shape.MediaMenuIcon} activeOpacity={.5} onPress={this.export}>
                    <Image source={Assets.img.icons.export_linear_icon} style={{
        width: 20,
        height: 20,
        resizeMode: 'contain',
        marginBottom: 5
      }} />
                    <Text style={[Typography.Light, Typography.Little]}>Export</Text>
                  </TouchableOpacity>
                  <TouchableOpacity style={Shape.MediaMenuIcon} activeOpacity={.5} onPress={this.delete}>
                    <Image source={Assets.img.icons.trash_linear_icon} style={{
        width: 20,
        height: 20,
        resizeMode: 'contain',
        marginBottom: 5
      }} />
                    <Text style={[Typography.Light, Typography.Little]}>Delete</Text>
                  </TouchableOpacity>
                </View> : <StatusBar hidden={true} />)}
          </View> : void 0)}
    </View>;
  }

};

Shape = StyleSheet.create({
  Box: {
    flex: 1,
    width: '100%',
    backgroundColor: 'black'
  },
  Content: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center'
  },
  MediaSlider: {
    alignItems: 'center',
    justifyContent: 'center'
  },
  MediaSliderItem: {
    flex: 1,
    width: '100%',
    alignItems: 'center',
    justifyContent: 'center',
    overflow: 'hidden'
  },
  MediaMenu: {
    position: 'absolute',
    width: '100%',
    height: 56,
    alignItems: 'center',
    flexDirection: 'row',
    justifyContent: 'space-between',
    backgroundColor: 'rgba(0,0,0,.2)'
  },
  MediaMenuIcon: {
    alignItems: 'center',
    justifyContent: 'center'
  }
});

export default Hybrid(MediaViewer);

//# sourceMappingURL=media_viewer.js.map
